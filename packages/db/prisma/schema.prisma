
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                @id @default(cuid())
  email                  String                @unique
  name                   String?
  emailVerified          DateTime?
  password               String
  image                  String?
  teacher_status         UserStatus            @default(PENDING)  // Better name
  role                   UserRole              @default(TEACHER)

  lectures               Lecture[]
  signupRequests         SignupRequest[]       // Fixed naming
  leavesRequested        LeaveRequest[]        @relation("RequestedLeaves")
  leavesAssigned         LeaveRequest[]        @relation("AssignedLeaves")
  replacementOffered     ReplacementOffer[]    @relation("OffersMade")
  replacementAccepted    ReplacementOffer[]    @relation("OffersAccepted")
  leavesApproved         LeaveRequest[]        @relation("ApprovedLeaves") //For Admin/HOD
  replacementsApproved   ReplacementOffer[]    @relation("ApprovedReplacements") // For Admin/HOD
  applications            ApplicationLeave[]   @relation("Applications")
  
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
}

// Normalize subjects into separate model
model Subject {
  id       String    @id @default(cuid())
  name     String    @unique
  code     String?   @unique
  
  lectures Lecture[]
}

model TimeSlot {
  id        String    @id @default(cuid())
  startTime DateTime  @unique
  endTime   DateTime  @unique
  label     String

  lectures  Lecture[]
}

model Lecture {
  id                     String    @id @default(cuid())
  timeSlotId             String
  teacherId              String
  subjectId              String
  date                   DateTime
  room                   String?
  weekDay                Int
  
  teacher                User              @relation(fields: [teacherId], references: [id])
  subject                Subject           @relation(fields: [subjectId], references: [id])
  timeSlot               TimeSlot          @relation(fields: [timeSlotId], references: [id])
  leaveRequest           LeaveRequest?
  replacementOffers      ReplacementOffer[] @relation("OriginalLecture")
  replacementLectures    ReplacementOffer[] @relation("ReplacementLecture")
  
  @@unique([teacherId, subjectId, date, timeSlotId])
}

model ReplacementOffer {
  id                String      @id @default(cuid())
  leaveId           String?
  lectureId         String      // Original lecture (teacher requesting replacement)
  replaceLectureId  String?     // Lecture the replacement teacher will teach instead
  offererId         String      // Teacher offering replacement
  accepterId        String      // Teacher accepting replacement
  approverId        String?
  message           String?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  status            OfferStatus @default(PENDING)

  // Relations
  lecture           Lecture     @relation("OriginalLecture", fields: [lectureId], references: [id], onDelete: Cascade)
  replaceLecture    Lecture?    @relation("ReplacementLecture", fields: [replaceLectureId], references: [id], onDelete: Cascade)
  leave             LeaveRequest? @relation("replacements", fields: [leaveId], references: [id], onDelete: Cascade)
  offerer           User        @relation("OffersMade", fields: [offererId], references: [id])
  accepter          User        @relation("OffersAccepted", fields: [accepterId], references: [id])
  approver          User?       @relation("ApprovedReplacements", fields: [approverId], references: [id])
  
  @@index([accepterId, status])
  @@index([lectureId])
  @@index([replaceLectureId])
}

model LeaveRequest {
  id                    String      @id @default(cuid())
  requesterId           String
  lectureId             String      @unique
  approverId            String?
  reason                String
  assignedToId          String?
  status                LeaveStatus @default(PENDING)  // Specific enum
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt

  replacementOffers     ReplacementOffer[] @relation("replacements")
  assignedTo            User?              @relation("AssignedLeaves", fields: [assignedToId], references: [id])
  requester             User               @relation("RequestedLeaves", fields: [requesterId], references: [id])
  approver              User?              @relation("ApprovedLeaves", fields: [approverId], references: [id])
  lecture               Lecture           @relation(fields: [lectureId], references: [id])
  application           ApplicationLeave? @relation("LeaveRequestApplication")
}

model ApplicationLeave {  
  id              String      @id @default(cuid())
  applicantId     String
  leaveRequestId  String   @unique
  s3ObjectKey     String

  leaveRequest LeaveRequest @relation("LeaveRequestApplication", fields: [leaveRequestId], references: [id], onDelete: Cascade)
  applicant   User       @relation("Applications", fields: [applicantId], references: [id])

  @@index([leaveRequestId, s3ObjectKey])
}

model SignupRequest { // Fixed naming consistency
  id            String        @id @default(cuid())
  name          String?
  email         String        @unique
  teacherId     String
  status        RequestStatus @default(PENDING)
  createdAt     DateTime      @default(now())
  
  teacher       User @relation(fields: [teacherId], references: [id])
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime
  
  @@unique([email, token])
}

// Separate enums for different contexts
enum UserRole {
  HOD
  ADMIN
  TEACHER
}

enum UserStatus {  // Renamed from Status
  PENDING
  ACTIVE
  INACTIVE
}

enum LeaveStatus {
  PENDING
  APPROVED  // Changed from SUCCESS
  DENIED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum RequestStatus {
  PENDING
  APPROVED
  DENIED
}
